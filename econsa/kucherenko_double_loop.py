"""Functions for comuputation of global sensitivity indices with dependent variables.

Here we implement the double-loop (or brute force) approximation of the integrals,
which are needed to be solved to calculate the generalized Sobol indices.

TODO:
    - Evaluations resort after shifting...
"""
from collections import namedtuple
from functools import partial
from itertools import count

import chaospy as cp
import numpy as np

from econsa.kucherenko import _shift_cov
from econsa.kucherenko import _shift_mean
from econsa.kucherenko import _uniform_to_multivariate_normal


def _first_order_index(func, mean, cov, scheme, n_outer, n_inner, n_joint, seed, skip):
    """what the fuck.

    Args:
        func ([type]): [description]
        mean ([type]): [description]
        cov ([type]): [description]
        scheme ([type]): [description]
        n_outer ([type]): [description]
        n_inner ([type]): [description]
        seed ([type]): [description]
        skip ([type]): [description]

    Returns:
        [type]: [description]
    """
    samples = _create_samples(mean, cov, scheme, n_outer, n_inner, n_joint, seed, skip)

    evals = _evaluate_func(func, samples)

    double_integral = _approximate_double_integral(evals)
    func_mean = _compute_mean(evals)
    func_variance = _compute_variance(evals, func_mean)

    index = (double_integral - func_mean ** 2) / func_variance
    return index


def _approximate_double_integral(evals):
    """[summary]

    Args:
        evals ([type]): [description]

    Returns:
        double_integral (np.ndarray): The approximate double integral for each variable;
            has shape (n_params,).
    """
    inner_integral = evals.integral.mean(axis=2)
    outer_integrand = inner_integral ** 2
    double_integral = outer_integrand.mean(axis=1)
    return double_integral


def _compute_mean(evals):
    """[summary]

    Args:
        evals ([type]): [description]

    Returns:
        mean (float): The mean.

    """
    mean = evals.joint.mean()
    return mean


def _compute_variance(evals, mean):
    """[summary]

    Args:
        evals ([type]): [description]
        mean ([type]): [description]

    Returns:
        var (float): The variance.
    """
    var = (evals.joint ** 2).mean() - mean ** 2
    return var


def _evaluate_func(func, samples):
    """[summary]

    Args:
        func (callable): Function which we want to evaluate on given samples.
        samples (namedtuple): Samples generated by function ``_create_samples``.

    Returns:
        evals (namedtuple): Named tuple with entries:
            - integral: Function evaluations using samples.outer and samples.inner
                which are used to approximate the double integral; has shape
                (len(mean), n_outer, n_inner).
            - joint: Function evaluations using samples.joint, has shape (n_joint,).

    """
    n_outer, n_params, n_inner, _ = samples.inner.shape

    evals_joint = np.apply_along_axis(func, 1, samples.joint)

    evals_integral = np.empty((n_params, n_outer, n_inner))
    for k in range(n_params):
        outer_samples = samples.outer[:, k]  # noqa: F841
        inner_samples = samples.inner[:, k, ...]  # noqa: F841
        # do something

        evals_integral[k, ...] = foo  # noqa: F821

    evals = namedtuple("Evals", "integral joint")(
        integral=evals_integral, joint=evals_joint
    )
    return evals


def _create_samples(
    mean, cov, scheme="sobol", n_outer=1000, n_inner=1000, n_joint=1000, seed=0, skip=0
):
    """

    Args:
        mean (np.ndarray): 1d mean of distribution.
        cov (np.ndarray): 2d covariance of distribution.
        scheme (str): one of ["sobol", "random"].
        n_outer (int): number of samples to draw for outer intgral.
        n_inner (int): number of samples to draw for inner integral.
        n_joint (int): number of samples to draw from joint distribution.
        seed (int): random number generator seed.
        skip (int): how many values to skip of the sobol sequence.

    Returns:
        samples (namedtuple): Named tuple with entries:
            - outer: Samples for outer integral, has shape (n_outer, len(mean))
            - inner: Samples for inner integral, has shape (n_outer, len(mean), n_inner,
                len(mean)-1)
            - joint: Samples of joint distribution, has shape (n_joint, len(mean))

    """
    seed_counter = count(seed)
    joint_samples = _create_joint_sample(mean, cov, scheme, n_joint, seed_counter, skip)
    outer_samples = _create_outer_sample(mean, cov, scheme, n_outer, seed_counter, skip)
    inner_samples = _create_inner_sample(
        outer_samples, mean, cov, scheme, n_inner, seed_counter, skip
    )

    samples = namedtuple("Samples", "outer inner joint")(
        outer=outer_samples, inner=inner_samples, joint=joint_samples
    )
    return samples


def _create_inner_sample(outer_sample, mean, cov, scheme, n_inner, seed_counter, skip):
    """Sample points for inner integral depedent on outer samples.

    Args:
        outer_sample (np.ndarray): Samples created using ``_create_outer_sample``.
            Has shape (n_outer, len(mean)).
        mean (np.ndarray): 1 dim. mean of distribution.
        cov (np.ndarray): 2 dim. covariance of distribution.
        scheme (str): one of ["sobol", "random"].
        n_inner (int): number of samples to draw.
        seed_counter (itertools.count): random number generator seed counter.
        skip (int): how many values to skip of the sobol sequence.

    Returns:
        inner_sample (np.ndarray): Array of shape (n_outer, len(mean), n_inner, len(mean) - 1)
            containing the conditional samples dependent on the outer_sample. That is, for each
            entry in outer_sample, we obtain a sample of size (n_inner, len(mean) - 1).

    """
    n_outer, n_params = outer_sample.shape

    conditional_mean = _conditional_mean(outer_sample, mean, cov)
    conditional_cov = _conditional_cov(outer_sample, mean, cov)

    inner_sample = np.empty((n_outer, n_params, n_inner, n_params - 1))

    for k in range(n_params):
        cond_mean = conditional_mean[k, ...]
        cond_cov = conditional_cov[k, ...]

        func = partial(
            _draw_conditional_samples,
            cov=cond_cov,
            n_draws=n_inner,
            scheme=scheme,
            seed=next(seed_counter),
            skip=skip,
        )

        samples = np.apply_along_axis(func, 1, cond_mean)
        inner_sample[:, k, ...] = samples

    return inner_sample


def _conditional_mean(outer_sample, mean, cov):
    """[summary]

    Args:
        outer_sample (np.ndarray): Samples created using ``_create_outer_sample``.
            Has shape (n_outer, len(mean)).
        mean (np.ndarray): 1 dim. mean of distribution.
        cov (np.ndarray): 2 dim. covariance of distribution.

    Returns:
        conditional_mean (np.ndarray): Array of shape (len(mean), n_outer, len(mean)-1) containing
            for each variable k=1,...,len(mean), for each i=1,...,n_outer the mean of all other
            variables conditioned on observering for the k-th variable outer_sample[i, k].

    """
    n_outer, n_params = outer_sample.shape

    conditional_mean = np.empty((n_params, n_outer, n_params - 1))
    for k in range(n_params):
        cov_shifted = _shift_cov(cov, k)
        mean_shifted = _shift_mean(mean, k)
        cov_a, _, cov_ab = _extract_subset_cov(cov_shifted)
        mean_a, mean_b = _extract_subset_mean(mean_shifted)
        update = (
            cov_ab.dot(np.linalg.inv(cov_a))
            .dot((outer_sample[:, k, None] - mean_a).T)
            .T
        )
        conditional_mean[k, ...] = mean_b + update

    return conditional_mean


def _conditional_cov(outer_sample, mean, cov):
    """[summary]

    Args:
        outer_sample (np.ndarray): Samples created using ``_create_outer_sample``.
            Has shape (n_outer, len(mean)).
        mean (np.ndarray): 1 dim. mean of distribution.
        cov (np.ndarray): 2 dim. covariance of distribution.

    Returns:
        conditional_cov (np.ndarray): Array of shape (len(mean), len(mean)-1, len(mean)-1),
            containing for each variable k=1,...,len(mean) the covariance of the other
            variables conditioned on variable k.

    """
    n_params = len(mean)

    conditional_cov = np.empty((n_params, n_params - 1, n_params - 1))
    for k in range(n_params):
        cov_shifted = _shift_cov(cov, k)
        cov_a, cov_b, cov_ab = _extract_subset_cov(cov_shifted)
        update = cov_ab.dot(np.linalg.inv(cov_a)).dot(cov_ab.T)
        conditional_cov[k, ...] = cov_b - update

    return conditional_cov


def _extract_subset_cov(cov):
    """[summary]

    Args:
        cov ([type]): [description]

    Returns:
        [type]: [description]
    """
    return cov[:1, :1], cov[1:, 1:], cov[1:, :1]


def _extract_subset_mean(mean):
    """[summary]

    Args:
        mean ([type]): [description]

    Returns:
        [type]: [description]
    """
    return mean[:1], mean[1:]


def _create_outer_sample(mean, cov, scheme, n_outer, seed_counter, skip):
    """Sample points for outer integral.

    For each k = 1,...,``len(mean)`` we sample from the marginal normal
    distribution with mean ``mean[k]`` and variance ``cov[k, k]``.

    Args:
        mean (np.ndarray): 1 dim. mean of distribution.
        cov (np.ndarray): 2 dim. covariance of distribution.
        scheme (str): one of ["sobol", "random"].
        n_outer (int): number of samples to draw.
        seed_counter (itertools.count): random number generator seed counter.
        skip (int): how many values to skip of the sobol sequence.

    Returns:
        outer_samples (np.ndarray): Array of shape (n_outer, len(mean)) containing
            independent samples from each parameter.

    """
    n_params = len(mean)
    u = _get_uniform_base_draws(n_outer, n_params, scheme, next(seed_counter), skip)
    diagonal_cov = np.diag(np.diag(cov))
    outer_samples = _uniform_to_multivariate_normal(u, mean, diagonal_cov)
    return outer_samples


def _create_joint_sample(mean, cov, scheme, n_joint, seed_counter, skip):
    """Sample points for estimation of mean and variance.

    We sample from the multivariate normal distribution defined by ``mean``
    and ``cov``.

    Args:
        mean (np.ndarray): 1 dim. mean of distribution.
        cov (np.ndarray): 2 dim. covariance of distribution.
        scheme (str): One of ["sobol", "random"].
        n_joint (int): Number of samples to draw.
        seed_counter (itertools.count): random number generator seed counter.
        skip (int): How many values to skip of the Sobol sequence.

    Returns:
        joint_samples (np.ndarray): Array of shape (n_joint, len(mean)) containing
            samples of the complete parameter vector.

    """
    n_params = len(mean)
    u = _get_uniform_base_draws(n_joint, n_params, scheme, next(seed_counter), skip)
    joint_samples = _uniform_to_multivariate_normal(u, mean, cov)
    return joint_samples


def _draw_conditional_samples(mean, cov, n_draws, scheme, seed, skip):
    """[summary]

    Args:
        mean ([type]): [description]
        cov ([type]): [description]
        n_draws ([type]): [description]
        scheme ([type]): [description]
        seed ([type]): [description]
        skip ([type]): [description]

    Returns:
        [type]: [description]

    """
    n_params = len(mean)
    u = _get_uniform_base_draws(n_draws, n_params, scheme, seed, skip)
    conditional_sample = _uniform_to_multivariate_normal(u, mean, cov)
    return conditional_sample


def _get_uniform_base_draws(n_draws, n_params, sampling_scheme, seed=0, skip=0):
    """Get uniform random draws.

    Args:
        n_draws (int): Number of uniform draws to generate.
        n_params (int): Number of parameters of model.
        sampling_scheme (str): one of ["sobol", "random"])
        seed (int): Random number generator seed; default is 0.
        skip (int): How many values to skip of the Sobol sequence.

    Returns:
        u (np.ndarray): Uniform draws; has shape (n_draws, n_params).

    """
    np.random.seed(seed)

    if sampling_scheme == "sobol":
        draws = cp.generate_samples(order=(n_draws + skip), domain=n_params, rule="S").T
    elif sampling_scheme == "random":
        draws = np.random.uniform(size=(n_draws, n_params))
    else:
        raise ValueError("Argument 'sampling_scheme' is not in {'sobol', 'random'}.")

    skip = skip if sampling_scheme == "sobol" else 0
    u = draws[skip:, :]
    return u
